Python

#desafio 73, 76, 80 e 83

Importar bibliotecas

import biblioteca  # importa todas as funções da bibliotecas

from biblioteca import func1, func2  importa somente as funções selecionadas de uma dada biblioteca

print(f'Na posição {p} encontrei o valor {v:.2f}', end='') # usado o f na frente para formatar como uma fstring e o end='' no final para poder emendar um texto no outro
print('-' * 20) # imprime 20 vezes - na tela

help(funcao) # traz todas as informações da função informada

a += b # abreviação para a = a + b

NumImagi = 5j #Declaração de numeros imaginários

iteravei = Tupla, lista, dicionário, set e strings

O tipo None sempre é considerado False


if lógica:
	comando
else:
	comando

if lógica:
	comando	
elif lógica:
	comando

#for
for c in range(0, 10)
	comando

for c in lista:
	comando

for pos, c in enumerate(c)
	comando

for _, b in c: # o _ é quando indice é descartável e será usado apenas para avançar no range, lista etc .
	comando	

for c in range(1,10):
	if c == x
		break		# break também funciona em for

#ranges
for x in range(11): # vai de 0 a 10 pois o ultimo numero do range é sempre vf-1
	pass

for x in range(1,11): # vai de 1 a 10 pois o ultimo numero do range é sempre vf-1
	pass

for x in range(1,10, 2): # vai de 1 a 10 pulando de 2 em 2 
	pass

for x in xrange(10, 0, -1): # vai de 10 até 1 de maneira regressiva
	pass

list = list(range(10)) # criando uma lista de valores de 0 até 9

#while
while (lógica):		# enquanto a lógica for verdadeira ele mantem o while
	comando

while lógica:   
	comando
	break     #sai do while 


#tuplas
 # tuplas são imutaveis e são indicadas por () parenteses
 # tuplas são mais rapidas de serem executada no programa
 # tuplas trazem mais segurança ao seu sistema
 # na tuplas não temos shallow copy
tupla = (a, b, c, d)  
tupla = a, b, c, d # outra maneira de declarar tupla
tupla = (4,) # tuplas são definidas pela virgula, se retirar a virgula, ele intenderá que é uma varável de outro valor
tupla = 4,  # idem a linha de cima
tupla = tuple(range[11])  # criando uma tupla com 11 elementos de 0 a 10

  #desempacotamento de tuplas
tupla = (5, 4, 7)
num1, num2, num3 = tupla  # o numero de varáveis deve ser igual ao numero de elementos

tuplaconc = tupla1 + tupla2  # concatenando tuplas
tupla1 = tupla1 + tupla2  # podemos sobreescrever tuplas, mas não altera-las

for indice, valor in enumerate(tupla)  # printa os indices e seus respectivos valores
	print(indice, valor)		

tupla.count('e')  # conta quantos elementos 'e' a tupla possue
tupla.index('e')  # informa o indice do primeiro 'e' que ele encontrar na tupla
print(sorted(tupla))  #traz em odem alfabética ou do menor para o maior
del(tupla) #deleta tupla

sum(tupla)  # soma dos elementos da tupla
max(tupla)	# maximo valor da tupla
min(tupla)	# minimo valor da tupla
len(tupla)	# tamanho da tupla



#listas
 # listas são mutaveis e indicadas por []
lista = [a, b, c, d] 
lista.index(b) # retorna o indice do primeiro b que ele achar na lista
lista.index(b, 3) # retorna o indice do primeiro b que ele achar na lista a partir do indice 3
lista.index(b, 6, 8) # retorna o indice do primeiro b que ele achar na lista a entre o indice 6 e o 8
lista.append(f) # adiciona um unico elemento a lista
lista.extend([e, f, g, h])  # inclui mais de um item na lista
lista.insert(0, aa) # insere o valor no index indicado 
lista.sort() # traz em odem alfabética ou do menor para o maior
lista.sort(reverse=True) # traz do maior para o menor
len(lista) # numero de elementos na lista
for indice, elemento in enumerate(lista)
	print(indice, elemento)
	"""irá printar
		0 elemento0
		1 elemento1
		2 elemento2"""

outro ex: lista = list(enumerate(lista))
		  output: [(0, elemento0), (1, elemento1), (2, elemento2)]    

	#como inputar valores manualmente em uma lista
valores = list()
for cont in range(0, 5)
	valores.append(int(input('Digite um valor: ')))

 #shallow copy	
listaC = listaB # cria uma ligação entre as duas listas, as duas terão os mesmos valores e o que for alterada em uma será alterada em outra
 
 #deep copy
listaC = listaB[:] # apenas copia os valores da listaB para a listaC, mas neste caso as duas são idependentes uma da outra sem a ligação feita na linha de cima
listaC = listaB.copy() # apenas copia os valores da listaB para a listaC, mas neste caso as duas são idependentes uma da outra sem a ligação feita na linha de cima

	# maneiras de retirar um elemento da lista
lanche.pop() #remove o ultimo item da lisra
lanche.pop(3) # remove o elemento c da lista
del lanche # deleta lista
del lanche[3] # remove o elemento c desta lista
lanche.remove('c') # remove o elemento c da lista
if 'c' in lanche
	lanche.remove('c')

sum(lista)  # soma dos elementos da lista
max(lista)	# maximo valor da lista
min(lista)	# minimo valor da lista
len(lista)	# tamanho da lista

lisat[0], lista[1] = lista[1], lista[0]  # invertendo posição dos valores da lista

# desempacotando lista, o numero de variaveis deve ser igual ao numero de elementos na lista 
lista[1, 2, 3]
num1, num2, num3 = lista

sLista = ' '.join(listaC) # Cria uma string com os elementos separados pelo que esta nas aspas simples

novalista = [valor * 2 for valor in lista] # list comprehension exmplo1
novalista = [valor * 2 for valor in lista if valor > 10] # list comprehension com if exmplo2
novalista = [ valor * 2 if valor > 10 else valor * 3 for valor in lista] # list comprehension com if else exmplo3
matriz = [[col for col in range(1, 4)] for lin in range(1, 4)] # list comprehension para criar uma matriz

#dicionários
 # dicionários são mutaveis e representados por {}
 # dicionarios são conhecidos também como mapas em outras linguagens
 # dicionários são coleções de tipo chave/valor
  TANTO AS CHAVES QUANTO OS VALORES PODEM RECEBER ELEMENTOS DE QUALQUER TIPO(int, float, string, tupla, lista, dicionário, boolean, etc)
 # recomendado usar tuplas nas chaves pois as tuplas são imutaveis, trazendo segurança aos dados do dicionário
dicionario = {'nome': 'a', 'sexo': 'b', 'rua': 'c', 'numero': 25}
dicionario = dict(nome= 'a', sexo= 'b', rua= 'c') # outra maneira de declarar dicionários
dicionario = {'nome': 'a',		# outra maneira de declarar dicionários
			  'sexo': 'b',
			  'rua': 'c',
			  'numero': 25	
			 }
 Maneira MASSA e pratica de criar um dicionário
dicionario = {}.fromkeys(['nome', 'pontos', 'email', 'profile'], 'desconhecido')
	"""o retorno disso é 
	{'nome': 'desconhecido', 'pontos': 'desconhecido', 'email': 'desconhecido', 'profile': 'desconhecido'}

	ele atribui o 'deschonhecido' como valor de todas as chaves 
	
	MAS CUIDADO, pois:
	dicionario = {}.fromkeys('nome', 'luiz') retorna
	{'n': 'luiz', 'o': 'luiz', 'm': 'luiz', 'e': 'luiz'}


	"""
dicionario[cidade] = 'd' #adiciona / atualizar um item ao dicionário
 # outra maneira de adicionar / atualizar itens ao dicionario
novo_dado = {'cidade': 'd'}
dicionario.update(novo_dado)

 # removendo itens de um dicionario
dicionario.pop('cidade') # no .pop() do dicionário SEMPRE é obrigatório passar a chave
ret = dicionario.pop('cidade') # a função pop() também retorna o valor removido, neste caso 'd'
del in dicionário['cidade'] # outra forma de remover um item

dicionario.clear() # limpa todo o dicionário

dicionario.copy() # faz o deep copy do dicionário
dicionario = dic2 # faz o shallow copy

print(dicionário['nome']) # imprime o valor relacionado a essa chave quando a chave não existe ele retorna KeyError
print(dicionário.get('nome')) # FORMA RECOMENDADA - imprime o valor relacionado a esta chave, quando a chave não existe ele retorna None
print(dicionário.get('nomeinexistente', 'Nome não encontrado')) # FORMA RECOMENDADA - caso não encontrado a chave informada ele retorna a mensagem que você digitar, neste caso 'Nome não encontrado'

print('nome' in dicionario)  # retorna o True ou falso

dicionario.values() # pega os valores de declarados nas keys (a, b, c, 25)
dicionario.keys() # pega os nomes das keys (nome, sexo, rua, numero)
dicionario.items() # traz as keys e seus respectivos valores em seguida ('nome': 'a', 'sexo': 'b', 'rua': 'c', 'numero': 25)

 # desempacotamento do dicionario k = chaves, v = valores
for k,v in dicionario.items():
	print(f'O {k} é {v}')

lista.append(dicionario) #adiciona ao dicionário dentro de uma lista - shalow copy
lista.append(dicionario.copy()) # copia o dicionário para dentro da lista - deep copy

from operetor import itemgetter # função de uma librarie que organiza um dicionário do menor para o maior
dicorg = sorted(dicionario.items(), key=itemgetter(1), reverse=True)

sum(dicionario.values())    # soma dos elementos do dicionario por tanto que os valores sejam int ou float
max(dicionario.values())	# maximo valor do dicionario por tanto que os valores sejam int ou float
min(dicionario.values())	# minimo valor do dicionario por tanto que os valores sejam int ou float
len(dicionario)	# tamanho do dicionario



novodict = {chave: valor * 2 for chave, valor in dicionario} # dict comprehension exemplo1
novodict = {valor: valor ** 2 for valor in listupla} # dict comprehension tranformando listas/tuplas em dicionáriop exemplo2

chavels = 'abcde'
valores = [1, 2, 3, 4, 5]
mistura = chaves[i], valores[i] for i in range(0, len(chaves)) # dict comprehension unificando iteraveis em apenas um dicionário exemplo3

novodict = {num: ('par' if num % 2 == 0 else 'impar') for num in numeros}  # dict comprehension usnado if para inputar os valores exemplo4



 #slicing de coleções - tanto para tupla, lista e dicionario
colecao[inicio:fim:passo]

# Sets
 # parecido com uma lista mas que não permite elementos iguais
 # NÃO SÃO INDEXADOS
 # por mais que usem {} eles não são dicionarios, pois possuem apenas valores
 # o set não respeita a ordenção de input, ele mesmo organiza os elementos

set = set({4, 3, 1, 2, 3}) # retorna {1, 2, 3, 4}
set = {4, 3, 1, 2, 3}  # retorna {1, 2, 3, 4}
set = set('luiz') # retorna {'z', 'i', 'l', 'u'}

set(lista) #gera o set de uma lista e tuplas
set(tupla)

set.add(3) # adicionando elemento no set, caso repetido ele apenas ignora o input

set.remove(3) # remove o valor especificado nos parenteses, NÃO é pelo INDICE, caso ele não exista no set, é dado KeyError
set.discard(3) # remove o valor especificado nos parenteses, NÃO é pelo INDICE, caso ele não exista no set nenhum erro é retornado
set.clear() # remove todos os elementos do set

novoset = set.copy() # deep copy

novoset = set # shallow copy

# união de conjuntos
useta = set1.union(set2) # gera um novo set que uni os dois sets, eliminando os elementos repetidos
usetb = set1 | set2 # gera um novo set que uni os dois sets, eliminando os elementos repetidos - outra forma

# interceção conjuntos
iseta = set1.intersect(set2) # gera um novo set somente com os elementos que aparecem no set1 e no set2
isetb = set1 & set2 # gera um novo set somente com os elementos que aparecem no set1 e no set2 - outra forma

# diferença de conjuntos
dset1a = set1.dif(set2) # gera um set de elementos só tem no set1
dset2a = set2.dif(set1) # gera um set de elementos só tem no set2

sum(dicionario.values())    # soma dos elementos do set por tanto que os valores sejam int ou float
max(dicionario.values())	# maximo valor do set por tanto que os valores sejam int ou float
min(dicionario.values())	# minimo valor do set por tanto que os valores sejam int ou float
len(dicionario)	# tamanho do set


novoset = {valor * 2 for valor in range(1, 8)} # set comprehension exmplo1
novoset = {valor * 2 for valor in range(1, 8) if valor > 10} # set comprehension com if exmplo2
novoset = {valor * 2 if valor > 10 else valor * 3 for valor in  range(1, 8)} # set comprehension com if else exmplo3


# modulo collections, funções uteis para coleções(Tupla, lista, dicionário, set)

from collections import Counter  # recebe um iterável e cria um collections.Couter parecido com um dicionário, onde a chave é o valor da coleção passada e o valor é o numero de ocorrencias deste elemento na coleção passada
from collections import defaultdict # cria um dicionário onde não ocorre Keyerror, sempre que á a tentativa de acessar ou printar uma chave que não exista no dicionário ele atribui um valor padrão através de lambda 
from collections import OrderedDict # com o OrderedDict cria-se um dicionário onde ele mantem sempre a sequencia de incerção de chaves e valores, pois em dicionários comuns, conforme inumeras incerções de chaves e valores ele não nos garante que a ordem de inserção seja mantida
from collections import namedtuple # Tuplas diferenciadas, onde criamos modelos de tuplas onde damos um nome e os parametros
from collections import deque # são listas de alta performance -uma lista com alguma funções adicionais que ajudam bastante
 
 #Counter
Counter = Counter(lista) 
CountS = Counter(Texto) # Inclusive conta o numero de letras e palavras em uma string
CountS.most_common(5) # retorna as 5 palavras que mais aparecem em uma string 

 #defaultdict
dDict = defaultdict(lambda: 0)

 #OrderedDict
oDict = OrderedDict({'a': 1, 'b': 2})
 """Exemplo: Em um if dic1 == dic2 o python compara se há chaves iguais e valores iguais independende da ordem 
 	agora no caso de um OrderedDict o if leva em consideração até a se a ordem das chaves estão iguais"""

 #namedtuple
  #declarando
cachorro = namedtuple('cachorro', 'idade raca nome') # forma 1
cachorro = namedtuple('cachorro', 'idade, raca, nome') # forma 2
cachorro = namedtuple('cachorro', ['idade', 'raca', 'nome']) # forma 3 - ESSA É MELHOR visualmente
  #usando
zouk = cachorro(idade=6, raca='bernese', nome='Zouk')
  #Acessando os dados
zouk[0] #idade # forma classica pelo indice da tupla -forma 1
zouk[1] #raca # forma classica pelo indice da tupla -forma 1
zouk[2] #nome # forma classica pelo indice da tupla -forma 1

zouk.idade # Direto pelo parametro da tupla -forma 2
zouk.raca # Direto pelo parametro da tupla -forma 2
zouk.nome # Direto pelo parametro da tupla -forma 2

 #deque
deq = deque()

deq.appendleft('a') #  adiciona no inicio da lista - funções adicionais
deq.popleft() # retira o primeiro elemnento da lista - funções adicionais



# funções
# Ordem de parametros a sere passados def fun(obrigatórios, *args, opcionais=True, **kwargs)

def funcao(a, b, c, d=0):  # d=0 parametro opcional
	""" Doc string """  # Informações da função na função helṕ()
	global x	# Comando para o programa usar e alterar a variavel global x, variaveis globais são as de fora da função
	x = a + b + c + d
	if a == b:		#podem haver varias opções de retorno, porém ele retornará apenas um dos returns
		return a
	elif c != d:
		return c
	elif a == 999
		return 1, 2, 3, 4
	return x 


num1, num2, num3, num4 = funcao(999, 0, 0) # declarando varias variaveis com um retorno de uma função que traz uma tupla no retorno

def function(num1, num2, fun=funcao): # declarando um dos parametros como uma função
	return fun(num1, num2)

def funinter():  # exemplo de uma função com outra dentro
	contador
	def dentro(): # esta função só e reconhecida dentro da função funinter
		nonlocal contador # non local é para pegar uma variavel de uma função acima
		contador += 1
		return contador
	return dentro()

func = funcao # nada muito usual, mas você pode declarar uma varivel igualando ela a uma função sem os ()


# *args
def funarg(*args):  # *args permite que seja passado varias variaveis transforma em uma tupla os inumeros elementos passados
	pass

funarg(*lista) # o * indica ao python para que desenpacote a lista ao executar a funcão, pois passar a lista em o * causa keyerror 

# **kwrags
def funkwarg(**kwrags): # exige que os parametros passados sejam nomeados, pois ele transforma os paramentros passados em um dicionário
	pass

funkwarg(nome=luiz, idade=26, code=python) # modo de chamar a função com **kwargs
	# neste caso abaixo, podemos informar os ** tanto se a função tiver como paramentro **kwargs
	# rambem como se a função tiver paramentos (a, b, c), porém neste caso o dicionário deve ter chaves chamadas a, b e c com seus respectivos valores, se o dicionário tiver chaves com o mesmo nome dos parametros obrigatórios ele pode ser desempacotado com ** 
funkwarg(**dicionario) # modo de chamar a função com **kwargs desenpacotando um dicionário



#lambda
	#lambda são funções sem nome 

lambda x:  3 * x + 1 # declarando uma lambda

# como utilizar
calc = lambda x: 3 * x + 1  # lambda exemplo1
calc(4) #retornara 13

nome_completo = lambda nome, sobrenome: nome.strip().titled() + ' ' + sobrenome.strip().titled()  # lambda exemplo2
calc2 = lambda x, y, z: x**2 + y**2 + z**2  # lambda exemplo3

def gera_fun_quadratica(a, b ,c):	# criando uma função com lambda
	return lambda x: a * x ** 2 + b * x + c

teste = gera_fun_quadratica(2, 3, -5) # igualando uma variavel a função gerada e passado os valores fixos de a, b e c

teste(0) # onde o valor entre 0 é o valor dado pra x e então junto com os valores estabelecidos ao declarar a varável  o python calcula o resultado de toda a formuda da função criada 
	#retornaria  -5, pois  5 * 0 ** 2 + 3 * 0 + (-5) 	


#map
	# Faz o mapeamento de valores para função
	# retorna um obj do tipo map
	# geralmente sua função atua/ altera os elementos do iterável
	# após o primeiro uso/conversão dos elemtnos internos do map ele é apagado automaticamente

var = map(fun, iteravel) # modo de uso exemplo1

var = map(lambda x: x**, iteravel) # usando lambda exemplo2

var = list(map(fun, iteravel)) # modo RECOMENDADO DE USO, pois após a visualização dos elementos ou conversão o map é apagado automaticamente exemplo3

  #exemplo4
cidades = [('Berlim, 29'), ('Cairo', 36)]  # lista com tuplas onde informa a cidade e a temperatura em ºC

c_para_f = lambda dado: (dado[0], (9/5) * dado[1] + 32)  # lambda onde apenas mantem o nome da cidade(dado[0), mas ao pegar o valor em ºC(dado[1]) converte para ºF 

conversão = list(map(c_para_f, cidades)) # usando maps para realizar a conversão e tranformando em uma lista

 lista = list(map(lambda nome: f'Sua prof é {nome}', filter(lambda nome: len(nome) < 5, nomes)))  # Criando uma lista usando Maps e Filters onde ele filtrar os nomes com menos de 5 caracteres e o maps faz com que printe o nome junto ao texto digitado exemplo5

#Filter
  # filter() - Serve para filtrar dados de uma determinada coleção
  # o retorno do filter é igual ao do maps, após o primeiro uso é apagado automaticamente
  # a função utilizada no filter sempre deve retornar True or False

filter(fun, iterável) # modo de usaron de a função ou lambda especicado em fun deve retornar true or false caso seja True ele traz o elemento exemplo1

filter(None, dados)  # elimina elementos em branco em uma lista Exemplo2 - DICA 

  #exemplo3
 usuários = [															# lista com usuários e seus tweets
 			{'username': 'luiz', 'tweets': ['Ola tudo bem?', 'Oi']}
 			{'username': 'klaus', 'tweets': []}
 			{'username': 'amanda', 'tweets': ['hahaha']}
 			{'username': 'alisson', 'tweets': []}
 ]

inativos = list(filter(lambda usuario: not usuario['tweets'], usuários))  # criando uma lista com o filter onde ele só irá filtrar os usuários  que não tweetaram nada

lista = list(map(lambda nome: f'Sua prof é {nome}', filter(lambda nome: len(nome) < 5, nomes)))  # Criando uma lista usando Maps e Filters onde ele filtrar os nomes com menos de 5 caracteres e o maps faz com que printe o nome junto ao texto digitado exemplo4


#Reduce
 	# Não é muito recomendado o uso, mas caso queira usa-la deve ser feito um (from functools import reduce)
 	# na maioria dos casos um loop for é mais legivel
 	# Seu funcionamento é como uma fatorial, digamos que a função passada seja somar apenas os elementos, o reduce irá fazer: a + b = res1, res1 + c = res2, res2 + d = res3, res3 + e = res4 ... resn 
 	# seu resultado é sempre um elemento só.

reduce(fun, iterável) # neste caso a função do reduce sempre deve pedir 2 elementos

res = 1
for n in valores:  # loop que se faz a mesma função do reduce
	res = res * n  # no lugar da operão de multiplicação pode ser colocado qualquer outra operação sempre entre o resultado anterior com o proximo valor


#Any e All
	# PARA O all() UM ITERAVEL VAZIO É TRUE - ATENÇÃO!!!

all()  # retorna True / verifica se todos os elementos do iterável são verdadeiros, RETORNA TRUE PARA ITERAVEIS VAZIOS - como se fosse um porta AND para todos os elementos do iterável, caso aja um como false ele retorna false, percebemos o comportamento de uma AND, salvo a exceção de quando o iterável esta VAZIO que ele retorna True
all([nome[0] == 'C' for nome in nomes])  # Verifica se a primeira letra(nome[0]) de todos os nomes da lista começam com C caso 1 dos nomes não comece ele irá retornar falso exemplo1


any() # retorna True / verifica se um elementos do iterável for verdadeiro, RETORNA FALSE PARA ITERAVEIS VAZIOS, percebemos o comportamento de uma OR
any(letra for letra in 'luiz' if letra in 'aeiou')  # verifica letra-a-letra em 'luiz' se é semenhande a alguma letra de 'aeiou' se achar uma letra se quer retornará True, caso não ache nenhuma retornará False exemplo1



#Generator expression
	# ocupa menos recurso em memória
	# semelhante ao list comprehenson
	# serve como um "esqueleto" para gerar iteráveis com list comprehension
	# ELE PODE SER ITERÁDO TAMBÉM

gen = (nome[0] == 'C' for nome in nomes)  # faz parte do list comprehenson, ele é parecido, mas é especificado entre (), neste caso ele ele gera uma variável do tipo generator, e aguarda ser atribuida a uma lista, tupla ou dicinário para poder executar as instruções entre os ()
 
lista = list(res) # gera uma lista a partir das intruções dentro de res, exemplo1  de uso



#Sorted
	# Podemos usar em qualquer iterável
	# retorna SEMPRE uma lista orgaaizando os elementos, Não modifica a atual
numeros = [6, 1, 8, 2]

sorted(numeros) # retorna SEMPRE uma lista com os elementos ordenados do menos para o maior, mas não altera a lista passada exemplo1

sorted(numeros, reverse=True)  # retorna a lista organizada, mas desta vez do maior para o menor exeṕlo2
x = tuple(sorted(numeros)) # exemplo3

 #exemplo4
usuários = [															# lista com usuários e seus tweets
 			{'username': 'luiz', 'tweets': ['Ola tudo bem?', 'Oi']}
 			{'username': 'klaus', 'tweets': []}
 			{'username': 'amanda', 'tweets': ['hahaha']}
 			{'username': 'alisson', 'tweets': []}
 ]

novosort = sorted(usuários, key= lambda usu: usu['username'])  # cria um novo iterável organzando os elementos pelo username por ordem alfabética
novosort = sorted(usuários, key= lambda usu: usu['username'], reverse=True) # cria um novo iterável organzando os elementos pelo username por ordem alfabética reversa
novosort = sorted(usuários, key= lambda usu: len(usu['tweets'])) # cria um novo iterável organzando os elementos pelo numero de tweets do menos para o maior


# max e min
	# pode ser usado lambda
	#exemplo de uso
mus = [
    {'titulo': 'Thunderstruck', 'tocou': 3},
    {'titulo': 'Hurricane', 'tocou': 2},
    {'titulo': 'Back in Black', 'tocou': 4},
    {'titulo': 'Afterlife', 'tocou': 25}
]

print(max(mus, key=lambda m: m['tocou'])['titulo'])



# reversed
	# inverte a ordem dos elementos de qualquer iterável
 #exemplos de uso
texto = 'luiz'
print(''.join(reversed(texto)))
tupla = (2, 3, 4, 5, 5)
for i in reversed(tupla):
    print(i)


# Len, Abs, Sum, Round
	# Abs - Retorna o valor absoluto de um numero real (sem o numero negativo)
	abs(-5)

	#Round - traz o valor arredondado de um float
	round(10.2)
	round(1.2567859, 2) # O ', 2' é numero de casas decimais que eu desejo


#zip
	# cria um objeto zip
	# após o primeiro uso é apagado automaticamente
	# caso nos iteraveis selecionados para zipar exista diferenças de tamanho ele respeitará o tamanho do menor iterável, ignorando os demais elementos das listas maiores
lista1 = [1, 2, 3]
lista2 = ['a', 'b', 'c']
zip1 = zip(lista1, lista2) 
zip1 = list(zip1)  # retorna [(1, 'a'), (2, 'b'), (3, 'c')]

dados = [(5, 'z'), (6, 'y'), (7, 'x'), (8, 'w')]
list(zip(*dados)) # retorna [(5, 6, 7 , 8), ('z', 'y', 'x', 'w')]  -  O * é o caracter usado para descompactação de listas 

 # exemplo mais complexo
prova1 = [80, 91, 78]
prova2 = [98, 89, 53]
alunos = ['luiz', 'pedro', 'felipe']

final = {dado[0]: max(dado[1], dado[2]) for dado in zip(alunos, prova1, prova2)}  # usando o dictionarie comprehension zipamos as 3 listas usando como chave o nome dos alinos e como valor a maior nota entre as provas

final = zip(alunos, map(lambda nota: max(nota), zip(prova1, prova2)))  # de outro jeito, USANDO MAP
final = dict(final) # convertando para dicionario





TRATANDO ERROS
"""
SyntaxError: quando há algo que o python não reconhece como parte da linguagem

NameError: Quando uma varável ou função não foi definida

TypeError: Ocorre quando uma função/operação/ação é aplicada com um tipo errado

IndexError: Ocorre quando tentamos acessar um elemnto em um iteravel com indexado utilixando um indice invalido.

ValueError: Ocorre quando uma função/operação built-in recebe um argumento com tipo correto mas o valor inapropriado

KeyError: Quando tentamos acessar uma chave inexistente de um dicionário

AttributeError: Ocorre quando uma variável(objeto) não tem um atributo/função

IndantationError: Ocorre quando não respeitamos a indentação do Python (4 espaços ou tab)


DICA: Execptions e erros saõ sinonimos na programação.
"""

#raise
	# não é uma função, mas sim uma palavra reservada
	# Util para que possamos passar a mensagem que desejamos no momento de um erro
	# O raise assim como o return finaliza a função, nada após ele é executado

raise ValueError('o valor ta erradaço') # exemplo1

 #exemplo2
def colore(texto, cor):
	cores = ('azul', 'verde', 'amarelo', 'branco')
	if type(texto) is not str:
		raise TypeError('texto precisa ser string')
	if type(cor) is not str:
		raise TypeError('cor precisa ser string')
	if cor not in cores:
		raise ValueError(f'A cor precisa ser entre: {cores}')
	print(f'O texto {texto} será impresso na cor {cor}')


#Try/Except
	# Serve para tratar de erros no programa, evitando assim que o mesmo pare e o usuário veja mensagens de erro na tela
	# tratar o erro de forma genérica não é uma boa prática, o correto é sempre tratar de maniera especifica, vide exemplo1

try:
	//execução problematica
except:
	//O que deve ser feito caso de problema

 #exemplo1
try:
	luiz()
except NameError:
	print('Vocês esta usando uma funçãou inexistente')

 #exemplo2 apresenta os detalhes do erro
try:
	luiz()
except NameError as err:
	print(f'Os detalhes do erro que ocorreu são os seguintes: {err}')

 # exemplo3  tratando de vários erros no mesmo try
try:
	luiz()
except NameError as erra:
	print(f'Os detalhes do erro que ocorreu são os seguintes: {err}')
except TypeError as erra:
	print(f'Os detalhes do erro que ocorreu são os seguintes: {err}')
except:							# tratamento para um tipo de erro não esperado
	print('erro desconhecido')

 # exemplo4  tratando de erros em uma função e dando o retorno devido para cada erro
def pega_valor(dicionario, chave)
	try:
		return dicionario[chave]
	except KeyError:
		return None
	except TypeError:
		return None

 #exemplo5 mais complexo
def dividir(a, b):    # toda a tratativa de erros deve ser feita dentro da função SEMPRE que possivel
	try:
 		return int(a) / int(b)  # converter as variveis dentro da função
 	except ValueError:
 		return 'valor incorreto'
 	except ZeroDivisionError:
 		return 'impossivel dividir por 0'

 #exemplo6 - forma Semi-generica
def dividir(a, b):    # toda a tratativa de erros deve ser feita dentro da função SEMPRE que possivel
	try:
 		return int(a) / int(b)  # converter as variveis dentro da função
 	except (ValueError,  ZeroDivisionError):
 		return 'Ocorreu um erro'


#Try, Except, Else, Finally
	# Dica de onde tratar erro: TODA ENTRADA DE DADOS EXTERNOS NO SISTEMA DEVE SER TRATADA
	# Else só executado se não ocorrer o erro.
	# O bloco Finally SEMPRE é executado, independente se houve exceção ou não
	# O Finally geralmente é usado para fechar e desalocar recursos. Ex: Ao abrir uma conexão com um banco de dados, caso haja erro o Finally de qualquer forma fechara a conexão
	# Você é responsavel pelas suas funções, por tanto trate as entradas

 # exemplo1	
try:
	server.abreConexão()
	l = server.luiz()
except NameError:
	print('Vocês esta usando uma funçãou inexistente')
else:
	print(l)
finally:
	server.fechaConexão()
	print('exectando finally')

 #exemplo2 mais complexo
def dividir(a, b):    # toda a tratativa de erros deve ser feita dentro da função SEMPRE que possivel
	try:
 		return int(a) / int(b)  # converter as variveis dentro da função
 	except ValueError:
 		return 'valor incorreto'
 	except ZeroDivisionError:
 		return 'impossivel dividir por 0'


 #exemplo - forma Semi-generica
def dividir(a, b):    # toda a tratativa de erros deve ser feita dentro da função SEMPRE que possivel
	try:
 		return int(a) / int(b)  # converter as variveis dentro da função
 	except (ValueError,  ZeroDivisionError):
 		return 'Ocorreu um erro'


# Debugando com PDB(Python Debugger)
	# no python 3.7+ se tornou uma função built-in
	# Debugger manual do python caso não esteja usando uma IDE
	# Comandos do pdb
	# l - kistar onde estamos no código
	# n - proxima linha
	# p - imprime veriável
	# c - continua o debugging

 #exemplo3 PARA PYTHON 3.7+
nome = 'luiz'
sobre = 'zanetti'
brakepoint()  # seta o brakepoint PYTHON 3.7+
nome_completo = nome + ' ' + sobre
curso = 'Curso de Python'
final = nome_completo + 'faz o curso' + curso


 #exemplo1
import pdb

nome = 'luiz'
sobre = 'zanetti'
pdb.set_trace()  # seta o brakepoint
nome_completo = nome + ' ' + sobre
curso = 'Curso de Python'
final = nome_completo + 'faz o curso' + curso

 #exemplo2
nome = 'luiz'
sobre = 'zanetti'
import pdb; pdb.set_trace()  # seta o brakepoint
nome_completo = nome + ' ' + sobre
curso = 'Curso de Python'
final = nome_completo + 'faz o curso' + curso


#Modulos, pacotes
	# modulos built-in são modulos já instalados junto com o python
	# qualquer arquivo .py pode ser usado como módulo, e o mesmo não pode ter linhas de códigos nele, apenas funções classes entre outros do genero
	# pacotes são diretórios com outros módulos e pacotes dentro dele

import modulo # importnado um modulo
from modulo import * # importnado o  modulo todo, de uma forma onde não é necessário escrever modulo.função(), passando a escrever apenas função()
from modulo import função #importando apenas uma função de um módulo
import modulo as mod # importando um modulo com um apelido mod
from modulo import função as fun # importando uma função  com um apelido fun
from modulo import função as fun , função2 as fun2, função3 as fun3# importando funções com um apelidos
from modulo import (			# modo bem utilizado para chamar multiplas funções de um modulo e podendo chamalas apenas por exemplo:  função2()
	função1,
	função2,
	função3,
	)
from pacote import modulo # importando pacote
 # modo de chamar no código pacote.modulo.funcao1()
from pacote.modulo import funcao1 # importando a função de um modulo dentro de um pacote
 # modo de chamar no código funcao1()
from pacote.pacoteinterno.modulo import funcao2 # importando a função de um modulo dentro de um pacote interno de um pacote
 # modo de chamar no código funcao2()

math - operações matematicas mais complexas e especificas 
statistics - para trabalhar com dados estatisticos
functools - 
sys - getsizeof(variável) # função que diz o espaço em memória ocupado pela variável especificada
secrets - gera numeros e tokens pseudo-aleatórios criptografados
random -  gera numeros pseudo-aleatórios e auxilia no uso e teste de iteráveis 
colorama  - modulo para poder imprimir de forma colorida no terminal
pypdf - auxilia na criação de pdf


#Dunder init e Dunder main
	# o nome Dunder vem de Double Under devido as variáveis com 2 underlines(ex: __init__ ,  __main__)
	# TODO ARQUIVO .py POSSUI AS VARIAVEIS INTERNAS   __init__ E __name__
	# AO EXECUTAR UM ARQUIVO .py O PYTHON ATRIBUIRÁ À VARIAVEL __name__ O VALOR __main__ INDICANDO QUE ESTE É O MÓDULO DE EXECUÇÃO PRINCIPAL
	# ISSO EXPLICA AS CHAMADAS QUE VEMOS DO TIPO ABAIXO
		if __name__ == '__main__':
			# código de execução
	# quando um arquivo .py é importado o __name__ dele é o próprio nome do arquivo


Leitura de arquivos

# função open() - abrindo um arquivo 'r'
	# ao abrir um arquivo com a função open() é criada uma conexão entre o seu programa e o arquivo no disco chamada de streaming
	#ao finalizar os trabalhos com o arquivos usamos a função close()
arquivo = open(texto.txt) #abre o arquivo e gera um objeto _io.TextIOWrapper

arquivo.read() # gera uma string com o contaudo do arquivo aberto, podemos limitar o numero caracteres a serem lidos basta especificar nos parenteses
arquivo.seek(0) # é utilizada para movimentar o cursor pelo arquivo onde 0 é a posição especificada para o cursor
arquivo.readline() # retorna uma string com a linha lida
arquivo.readlines() # retorna uma lista onde cada elemento é uma linha do arquivo

arquivo.close() # fechado a conexão(streaming) 
arquivo.closed() # verifica se o arquivo esta aberto ou fechado


# bloco with - MANEIRA CORRETA DE EDITAR ARQUIVOS
	# utilizado para criar um contexto de trabalho onde os recusrsos são fechados após o bloco with

with open('texto.txt') as arquivo: # assim que o código sai da identação do with o arquivo é fechado 
	print(arquivo.readlines())


# escrevendo em um arquivo 'w'
	# abrindo no modo 'w' caso ele não exista ele será criado
	# caso o arquivo ja exista ele será apagado e criado um novo com o novo conteudo

with open('texto.txt', 'w') as arquivo: # o 'w' indica que estamos abrindo o arquivo no modo de escrita
	arquivo.write('Muito fácil editar arquivos\n')
	arquivo.write('Luiz Henrique Zanetti')


# modos de abertura de arquivo
	'r' - Leitura
	'w' - escrita
	'x' - só abre para escrita caso não exista
	'a' - abre para escrita adicionando o conteudo ao final do arquivo, caso não exista será criado, com este modo não controlamos o cursor
	'+' - deve ser usado com uma das opções acima mas o '+' lhe da o controle do cursor e permite a escritura no arquivo, exemplo 'r+'
	#existem outros modos


#StringIO
	# Tanto na escritura quanto na leitura de arquivos é necessário ter a permissão do SO da maquina que esta executando o programa
	# Utilizado para ler e escrver em memória

from io import StringIO

mensagem - 'mensagem teste'

arquivo = StringIO(mensagem)  # foi criado uma variável onde ela atua como um arquivo de leitura/escrita
print(arquivo.read())
arquivo.write('teste') # desta forma podemos ler e até escrever no mesmo arquivo sem ter que ficar mudando o modo


# Navegando e obtendo informações de arquivos
import os 
os.getcwd() # traz o diretório de trabalho corrente
os.chdir('..')  # muda de pasta 
os.path.isabs('/home/geek/')  # verifica se é um path absoluto - OSX
os.path.isabs('C:\\Users\\luiz\\documento') # verifica se é um path absoluto - WINDOWS
os.name() #windows ele trará 'nt' para os demais trará o nome do linux ou mac
os.platform() # traz se é 32 ou 64 bits
os.path.join(os.getcwd(), 'novapasta') # cria uma nova pasta no caminho especificado(neste caso sera a pasta de trabalho corrente devido ao os.getcwd()).
os.path.join(os.getcwd(), 'novapasta', 'novasubpasta') # cria uma pasta e uma sub-pasta no caminho especificado(neste caso sera a pasta de trabalho corrente devido ao os.getcwd()).
os.listdir() # retorna uma lista com o nome do todas as pastas dento do caminho especificado
os.scandir() # retorna um iterável do tipo osx.ScandirIterator com o nome do todas as pastas dento do caminho especificado

 #funções do iterável gerado pelo os.scandir
 arquivo = os.scandir() # criando uma variável com o scandir
 arquivo[0].inode() # numeração do arquivo na ierarquia de diretórios
 arquivo[0].is_dir() # verificar se é um diretório
 arquivo[0].is_file() # vareificar se é um arquivo
 arquivo[0].is_symlink() # verificar se é um link simbólico
 arquivo[0].name # traz o nome do arquivo
 arquivo[0].path # caminho até o arquivo
 arquivo[0].stat()  # informa varios status sobre o arquivo (tamanho, etc)
 arquivo.close() # sempre que usamos a função scandir devemos fecha-la

#Manipulando Arquivos
import os

os.path.exists('path') # retorna se o arquivo existe
os.mknod('path') # cria um arquivo # apresenta erro se ja existir o arquivo
os.mkdir('path') # cria um diratório Obs: se não tiver permissão para criar ele não cria
os.mkdirs('path', exist_ok=True) # cria vários diretórios e o exist_ok=True faz com que não haja erro caso um dos diretórios ja exista
os.rename('path do arquivo/diretorio', 'path do arquivo/diretório com o novo nome') #caso não ache o arquivo da erro de File not found
os.remove('texto.txt') # deleta arquivos, NÃO JOGA NA LIXEIRA,DELETA DIRETO, caso esteja em uso dará erro
os.rmdir('path') #deleta um diretório, se houver arquivos dentro da pasta ele dará OS error
os.removedirs('path') # deleta varias pastas 
import send2trash # modulo que deleta os arquivos mas envia para a lixeira
send2trash('path')
import tempfile  # cria arquivos temporários
	#exemplo de uso do tempfile - NÃO funciona no WINDOWS
	with tempfile.TemporaryDirectory() as tmp:  #cria o diretório temposrário
		print(f'Criei o diretório temporário em {tmp}')  # mostra onde foi criado este diretório
		with open(os.path.join(tmp, 'arquivo_temporario.txt'), 'w') as arquivo:	# cria dentro do diretório tempoário um arquivo temporário 
			arquivo.write('Geek University\n') # escreve no arquivo
		input() # input criado apenas para verificar a criação do diretório e do arquivo, após o input tudo que estava dentro do diretório temporário inclusive o diretório temporário são excluidos

	#exemplo de criação de arquivos temporários	
	with tempfile.TemporaryFile() as tmp:
		tmp.write(b'Geek University\n') # em arquivos temporários a unica forma de escrever nos mesmos é através de bits, portanto o b no começo da string informa que o que foi escrito esta sendo convertido para bináriopara depois se tornar uma escrina no arquivo
		tmp.seek(0)
		print(tmp.read())


# Iterator e Iterable
	#Iterator
		# um obj que po ser iterado
		# um ibj que retorna um dado, sendo um elemento por vez quando uma função next() é chamada

	#Iterable
		# Um obj que irá retornar um iterator quando a função iter() for chamada


	# para criar um iterável crie um objeto e declare as opções __iter__ e __next__





it1 = iter(nome)	
it2 = iter(lista)

print(next(nome))
print(next(lista))





Site interessante:

https://www.cyberciti.biz/faq/install-snapd-on-fedora-linux-system-dnf-command/

pypi.org # site para achar, publicar e instalar modulos de python
 
https://pygobject.readthedocs.io/en/latest/getting_started.html#fedora-getting-started


https://pythonacademy.com.br/blog/desenvolva-aplicativos-para-android-ios-com-python-e-kivy


https://hackernoon.com/50-popular-python-open-source-projects-on-github-in-2018-c750f9bf56a0
https://medium.mybridge.co/36-amazing-python-open-source-projects-v-2019-2fe058d79450
https://medium.mybridge.co/34-amazing-python-open-source-libraries-for-the-past-year-v-2019-93d6ee11aceb

https://www.dataquest.io/blog/free-datasets-for-projects/

https://www.w3schools.com/python/python_exercises.asp


https://www.geeksforgeeks.org/clear-screen-python/ # limpando o console
'''https://intellij-support.jetbrains.com/hc/en-us/community/posts/360000129950-TERM-environment-variable-not-set-Mac-OS-os-system-clear-?page=1#community_comment_360000133004 '''  # setar essas configurações para os comandos a cima funcionarem

https://stackoverflow.com/questions/3620943/measuring-elapsed-time-with-the-time-module

Web

request > urls > view > model > response



LEMBRETES RAPIDOS

strng = ''.join(lista) # transformar lista em string

random.shuffle(lista) # embaralhar elementos de uma lista

random.uniform(1, 10) # gera valores reais(float) entre os valores estabelecidos 

secrets # modulo para gerar toquens e senhas criptografadas

  #função para dar clear direto no console
  # setar/colar TERM=xterm-color indo em Run > Edit configurations > Evironment variables  e tickar o check chamado Emulate terminal in output console
from os import system, name
def clear_console(so=''):
    if not so:
        so = name
    if so == 'nt':  # windows
        system('cls')
    else:  # Mac ou linux
        system('clear')

# maneiras de obter o output do console
from subprocess import Popen, PIPE

pipe = Popen("lsusb", shell=True, stdout=PIPE).stdout
output = pipe.read()

cmd = ['lsusb']
output = subprocess.Popen(cmd, stdout=subprocess.PIPE).communicate()[0]






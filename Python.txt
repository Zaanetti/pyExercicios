Python

#desafio 73, 76, 80 e 83

Importar bibliotecas

import biblioteca  # importa todas as funções da bibliotecas

from biblioteca import func1, func2  importa somente as funções selecionadas de uma dada biblioteca

print(f'Na posição {p} encontrei o valor {v:.2f}', end='') # usado o f na frente para formatar como uma fstring e o end='' no final para poder emendar um texto no outro
print('-' * 20) # imprime 20 vezes - na tela

help(funcao) # traz todas as informações da função informada

a += b # abreviação para a = a + b

NumImagi = 5j #Declaração de numeros imaginários

iteravei = Tupla, lista, dicionário, set e strings

O tipo None sempre é considerado False


if lógica:
	comando
else:
	comando

if lógica:
	comando	
elif lógica:
	comando

#for
for c in range(0, 10)
	comando

for c in lista:
	comando

for pos, c in enumerate(c)
	comando

for _, b in c: # o _ é quando indice é descartável e será usado apenas para avançar no range, lista etc .
	comando	

for c in range(1,10):
	if c == x
		break		# break também funciona em for

#ranges
for x in range(11): # vai de 0 a 10 pois o ultimo numero do range é sempre vf-1
	pass

for x in range(1,11): # vai de 1 a 10 pois o ultimo numero do range é sempre vf-1
	pass

for x in range(1,10, 2): # vai de 1 a 10 pulando de 2 em 2 
	pass

for x in xrange(10, 0, -1): # vai de 10 até 1 de maneira regressiva
	pass

list = list(range(10)) # criando uma lista de valores de 0 até 9

#while
while (lógica):		# enquanto a lógica for verdadeira ele mantem o while
	comando

while lógica:   
	comando
	break     #sai do while 


#tuplas
 # tuplas são imutaveis e são indicadas por () parenteses
 # tuplas são mais rapidas de serem executada no programa
 # tuplas trazem mais segurança ao seu sistema
 # na tuplas não temos shallow copy
tupla = (a, b, c, d)  
tupla = a, b, c, d # outra maneira de declarar tupla
tupla = (4,) # tuplas são definidas pela virgula, se retirar a virgula, ele intenderá que é uma varável de outro valor
tupla = 4,  # idem a linha de cima
tupla = tuple(range[11])  # criando uma tupla com 11 elementos de 0 a 10

  #desempacotamento de tuplas
tupla = (5, 4, 7)
num1, num2, num3 = tupla  # o numero de varáveis deve ser igual ao numero de elementos

tuplaconc = tupla1 + tupla2  # concatenando tuplas
tupla1 = tupla1 + tupla2  # podemos sobreescrever tuplas, mas não altera-las

for indice, valor in enumerate(tupla)  # printa os indices e seus respectivos valores
	print(indice, valor)		

tupla.count('e')  # conta quantos elementos 'e' a tupla possue
tupla.index('e')  # informa o indice do primeiro 'e' que ele encontrar na tupla
print(sorted(tupla))  #traz em odem alfabética ou do menor para o maior
del(tupla) #deleta tupla

sum(tupla)  # soma dos elementos da tupla
max(tupla)	# maximo valor da tupla
min(tupla)	# minimo valor da tupla
len(tupla)	# tamanho da tupla



#listas
 # listas são mutaveis e indicadas por []
lista = [a, b, c, d] 
lista.index(b) # retorna o indice do primeiro b que ele achar na lista
lista.index(b, 3) # retorna o indice do primeiro b que ele achar na lista a partir do indice 3
lista.index(b, 6, 8) # retorna o indice do primeiro b que ele achar na lista a entre o indice 6 e o 8
lista.append(f) # adiciona um unico elemento a lista
lista.extend([e, f, g, h])  # inclui mais de um item na lista
lista.insert(0, aa) # insere o valor no index indicado 
lista.sort() # traz em odem alfabética ou do menor para o maior
lista.sort(reverse=True) # traz do maior para o menor
len(lista) # numero de elementos na lista
for indice, elemento in enumerate(lista)
	print(indice, elemento)
	"""irá printar
		0 elemento0
		1 elemento1
		2 elemento2"""

outro ex: lista = list(enumerate(lista))
		  output: [(0, elemento0), (1, elemento1), (2, elemento2)]    

	#como inputar valores manualmente em uma lista
valores = list()
for cont in range(0, 5)
	valores.append(int(input('Digite um valor: ')))

 #shallow copy	
listaC = listaB # cria uma ligação entre as duas listas, as duas terão os mesmos valores e o que for alterada em uma será alterada em outra
 
 #deep copy
listaC = listaB[:] # apenas copia os valores da listaB para a listaC, mas neste caso as duas são idependentes uma da outra sem a ligação feita na linha de cima
listaC = listaB.copy() # apenas copia os valores da listaB para a listaC, mas neste caso as duas são idependentes uma da outra sem a ligação feita na linha de cima

	# maneiras de retirar um elemento da lista
lanche.pop() #remove o ultimo item da lisra
lanche.pop(3) # remove o elemento c da lista
del lanche # deleta lista
del lanche[3] # remove o elemento c desta lista
lanche.remove('c') # remove o elemento c da lista
if 'c' in lanche
	lanche.remove('c')

sum(lista)  # soma dos elementos da lista
max(lista)	# maximo valor da lista
min(lista)	# minimo valor da lista
len(lista)	# tamanho da lista

lisat[0], lista[1] = lista[1], lista[0]  # invertendo posição dos valores da lista

# desempacotando lista, o numero de variaveis deve ser igual ao numero de elementos na lista 
lista[1, 2, 3]
num1, num2, num3 = lista



sLista = ' '.join(listaC) # Cria uma string com os elementos separados pelo que esta nas aspas simples


#dicionários
 # dicionários são mutaveis e representados por {}
 # dicionarios são conhecidos também como mapas em outras linguagens
 # dicionários são coleções de tipo chave/valor
  TANTO AS CHAVES QUANTO OS VALORES PODEM RECEBER ELEMENTOS DE QUALQUER TIPO(int, float, string, tupla, lista, dicionário, boolean, etc)
 # recomendado usar tuplas nas chaves pois as tuplas são imutaveis, trazendo segurança aos dados do dicionário
dicionario = {'nome': 'a', 'sexo': 'b', 'rua': 'c', 'numero': 25}
dicionario = dict(nome= 'a', sexo= 'b', rua= 'c') # outra maneira de declarar dicionários
dicionario = {'nome': 'a',		# outra maneira de declarar dicionários
			  'sexo': 'b',
			  'rua': 'c',
			  'numero': 25	
			 }
 Maneira MASSA e pratica de criar um dicionário
dicionario = {}.fromkeys(['nome', 'pontos', 'email', 'profile'], 'desconhecido')
	"""o retorno disso é 
	{'nome': 'desconhecido', 'pontos': 'desconhecido', 'email': 'desconhecido', 'profile': 'desconhecido'}

	ele atribui o 'deschonhecido' como valor de todas as chaves 
	
	MAS CUIDADO, pois:
	dicionario = {}.fromkeys('nome', 'luiz') retorna
	{'n': 'luiz', 'o': 'luiz', 'm': 'luiz', 'e': 'luiz'}


	"""
dicionario[cidade] = 'd' #adiciona / atualizar um item ao dicionário
 # outra maneira de adicionar / atualizar itens ao dicionario
novo_dado = {'cidade': 'd'}
dicionario.update(novo_dado)

 # removendo itens de um dicionario
dicionario.pop('cidade') # no .pop() do dicionário SEMPRE é obrigatório passar a chave
ret = dicionario.pop('cidade') # a função pop() também retorna o valor removido, neste caso 'd'
del in dicionário['cidade'] # outra forma de remover um item

dicionario.clear() # limpa todo o dicionário

dicionario.copy() # faz o deep copy do dicionário
dicionario = dic2 # faz o shallow copy

print(dicionário['nome']) # imprime o valor relacionado a essa chave quando a chave não existe ele retorna KeyError
print(dicionário.get('nome')) # FORMA RECOMENDADA - imprime o valor relacionado a esta chave, quando a chave não existe ele retorna None
print(dicionário.get('nomeinexistente', 'Nome não encontrado')) # FORMA RECOMENDADA - caso não encontrado a chave informada ele retorna a mensagem que você digitar, neste caso 'Nome não encontrado'

print('nome' in dicionario)  # retorna o True ou falso

dicionario.values() # pega os valores de declarados nas keys (a, b, c, 25)
dicionario.keys() # pega os nomes das keys (nome, sexo, rua, numero)
dicionario.items() # traz as keys e seus respectivos valores em seguida ('nome': 'a', 'sexo': 'b', 'rua': 'c', 'numero': 25)

 # desempacotamento do dicionario k = chaves, v = valores
for k,v in dicionario.items():
	print(f'O {k} é {v}')

lista.append(dicionario) #adiciona ao dicionário dentro de uma lista - shalow copy
lista.append(dicionario.copy()) # copia o dicionário para dentro da lista - deep copy

from operetor import itemgetter # função de uma librarie que organiza um dicionário do menor para o maior
dicorg = sorted(dicionario.items(), key=itemgetter(1), reverse=True)

sum(dicionario.values())    # soma dos elementos do dicionario por tanto que os valores sejam int ou float
max(dicionario.values())	# maximo valor do dicionario por tanto que os valores sejam int ou float
min(dicionario.values())	# minimo valor do dicionario por tanto que os valores sejam int ou float
len(dicionario)	# tamanho do dicionario

 #slicing de coleções - tanto para tupla, lista e dicionario
colecao[inicio:fim:passo]

# Sets
 # parecido com uma lista mas que não permite elementos iguais
 # NÃO SÃO INDEXADOS
 # por mais que usem {} eles não são dicionarios, pois possuem apenas valores
 # o set não respeita a ordenção de input, ele mesmo organiza os elementos

set = set({4, 3, 1, 2, 3}) # retorna {1, 2, 3, 4}
set = {4, 3, 1, 2, 3}  # retorna {1, 2, 3, 4}
set = set('luiz') # retorna {'z', 'i', 'l', 'u'}

set(lista) #gera o set de uma lista e tuplas
set(tupla)

set.add(3) # adicionando elemento no set, caso repetido ele apenas ignora o input

set.remove(3) # remove o valor especificado nos parenteses, NÃO é pelo INDICE, caso ele não exista no set, é dado KeyError
set.discard(3) # remove o valor especificado nos parenteses, NÃO é pelo INDICE, caso ele não exista no set nenhum erro é retornado
set.clear() # remove todos os elementos do set

novoset = set.copy() # deep copy

novoset = set # shallow copy

# união de conjuntos
useta = set1.union(set2) # gera um novo set que uni os dois sets, eliminando os elementos repetidos
usetb = set1 | set2 # gera um novo set que uni os dois sets, eliminando os elementos repetidos - outra forma

# interceção conjuntos
iseta = set1.intersect(set2) # gera um novo set somente com os elementos que aparecem no set1 e no set2
isetb = set1 & set2 # gera um novo set somente com os elementos que aparecem no set1 e no set2 - outra forma

# diferença de conjuntos
dset1a = set1.dif(set2) # gera um set de elementos só tem no set1
dset2a = set2.dif(set1) # gera um set de elementos só tem no set2

sum(dicionario.values())    # soma dos elementos do set por tanto que os valores sejam int ou float
max(dicionario.values())	# maximo valor do set por tanto que os valores sejam int ou float
min(dicionario.values())	# minimo valor do set por tanto que os valores sejam int ou float
len(dicionario)	# tamanho do set



# modulo collections, funções uteis para coleções(Tupla, lista, dicionário, set)

from collections import Counter  # recebe um iterável e cria um collections.Couter parecido com um dicionário, onde a chave é o valor da coleção passada e o valor é o numero de ocorrencias deste elemento na coleção passada
from collections import defaultdict # cria um dicionário onde não ocorre Keyerror, sempre que á a tentativa de acessar ou printar uma chave que não exista no dicionário ele atribui um valor padrão através de lambda 
from collections import OrderedDict # com o OrderedDict cria-se um dicionário onde ele mantem sempre a sequencia de incerção de chaves e valores, pois em dicionários comuns, conforme inumeras incerções de chaves e valores ele não nos garante que a ordem de inserção seja mantida
from collections import namedtuple # Tuplas diferenciadas, onde criamos modelos de tuplas onde damos um nome e os parametros
from collections import deque # são listas de alta performance -uma lista com alguma funções adicionais que ajudam bastante
 
 #Counter
Counter = Counter(lista) 
CountS = Counter(Texto) # Inclusive conta o numero de letras e palavras em uma string
CountS.most_common(5) # retorna as 5 palavras que mais aparecem em uma string 

 #defaultdict
dDict = defaultdict(lambda: 0)

 #OrderedDict
oDict = OrderedDict({'a': 1, 'b': 2})
 """Exemplo: Em um if dic1 == dic2 o python compara se há chaves iguais e valores iguais independende da ordem 
 	agora no caso de um OrderedDict o if leva em consideração até a se a ordem das chaves estão iguais"""

 #namedtuple
  #declarando
cachorro = namedtuple('cachorro', 'idade raca nome') # forma 1
cachorro = namedtuple('cachorro', 'idade, raca, nome') # forma 2
cachorro = namedtuple('cachorro', ['idade', 'raca', 'nome']) # forma 3 - ESSA É MELHOR visualmente
  #usando
zouk = cachorro(idade=6, raca='bernese', nome='Zouk')
  #Acessando os dados
zouk[0] #idade # forma classica pelo indice da tupla -forma 1
zouk[1] #raca # forma classica pelo indice da tupla -forma 1
zouk[2] #nome # forma classica pelo indice da tupla -forma 1

zouk.idade # Direto pelo parametro da tupla -forma 2
zouk.raca # Direto pelo parametro da tupla -forma 2
zouk.nome # Direto pelo parametro da tupla -forma 2

 #deque
deq = deque()

deq.appendleft('a') #  adiciona no inicio da lista - funções adicionais
deq.popleft() # retira o primeiro elemnento da lista - funções adicionais



# funções
def funcao(a, b, c, d=0):  # d=0 parametro opcional
	""" Doc string """  # Informações da função na função helṕ()
	global x	# Comando para o programa usar e alterar a variavel global x, variaveis globais são as de fora da função
	x = a + b + c + d
	if a == b:		#podem haver varias opções de retorno, porém ele retornará apenas um dos returns
		return a
	elif c != d:
		return c
	elif a == 999
		return 1, 2, 3, 4
	return x 


num1, num2, num3, num4 = funcao(999, 0, 0) # declarando varias variaveis com um retorno de uma função que traz uma tupla no retorno

def function(num1, num2, fun=funcao): # declarando um dos parametros como uma função
	return fun(num1, num2)

def funinter():  # exemplo de uma função com outra dentro
	contador
	def dentro(): # esta função só e reconhecida dentro da função funinter
		nonlocal contador # non local é para pegar uma variavel de uma função acima
		contador += 1
		return contador
	return dentro()

func = funcao # nada muito usual, mas você pode declarar uma varivel igualando ela a uma função sem os ()






bibliotecas

math - operações matematicas mais complexas e especificas 



Site interessante:

https://pygobject.readthedocs.io/en/latest/getting_started.html#fedora-getting-started


https://pythonacademy.com.br/blog/desenvolva-aplicativos-para-android-ios-com-python-e-kivy


https://hackernoon.com/50-popular-python-open-source-projects-on-github-in-2018-c750f9bf56a0
https://medium.mybridge.co/36-amazing-python-open-source-projects-v-2019-2fe058d79450
https://medium.mybridge.co/34-amazing-python-open-source-libraries-for-the-past-year-v-2019-93d6ee11aceb


Web

request > urls > view > model > response